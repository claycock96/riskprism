#!/usr/bin/env bash
set -e

# Ensure we are running from the project root (optional for CLI but good for consistency)
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
# Note: riskprism doesn't strictly need root cd, but we'll include it for internal consistency
# if it ever needs to reference project assets.
# cd "$SCRIPT_DIR/.."

# riskprism - CLI tool for RiskPrism security analysis
# Usage: riskprism <plan-or-policy-file> [api-url]

# Color codes
RED='\033[0;31m'
YELLOW='\033[1;33m'
GREEN='\033[0;32m'
BLUE='\033[0;34m'
BOLD='\033[1m'
NC='\033[0m' # No Color

# Helper for colored output that works across shells
log_color() {
    local color=$1
    shift
    printf "${color}%b${NC}\n" "$*"
}

# Default values
API_URL="http://localhost:8000"
STRICT_NO_STORE=false
PLAN_FILE=""

# Simple flag parsing
while [[ "$#" -gt 0 ]]; do
    case "$1" in
        -n|--no-store)
            STRICT_NO_STORE=true
            shift
            ;;
        -u|--api-url)
            API_URL="$2"
            shift 2
            ;;
        -h|--help)
            echo "Usage: riskprism [options] <file> [api-url]"
            echo ""
            echo "Options:"
            echo "  -n, --no-store    Disable session storage on the server"
            echo "  -u, --api-url URL Specify the API URL (default: http://localhost:8000)"
            echo "  -h, --help        Show this help message"
            echo ""
            echo "Documentation: CLI_USAGE.md"
            exit 0
            ;;
        *)
            if [ -z "$PLAN_FILE" ]; then
                PLAN_FILE="$1"
            else
                # If PLAN_FILE is already set, treat this as API_URL for backward compat
                API_URL="$1"
            fi
            shift
            ;;
    esac
done

# Check if file provided
if [ -z "$PLAN_FILE" ]; then
    echo "Usage: riskprism [options] <file> [api-url]"
    echo "Try 'riskprism --help' for more information."
    exit 1
fi

# Check if plan file exists
if [ ! -f "$PLAN_FILE" ]; then
    log_color "$RED" "Error: Plan file '$PLAN_FILE' not found"
    exit 1
fi

# Check if terraform is installed
if ! command -v terraform &> /dev/null; then
    log_color "$RED" "Error: terraform command not found"
    echo "Please install Terraform: https://www.terraform.io/downloads"
    exit 1
fi

# Check if jq is installed
if ! command -v jq &> /dev/null; then
    log_color "$YELLOW" "Warning: jq not found. Installing for better output formatting..."
    # Try to install jq based on OS
    if [[ "$OSTYPE" == "darwin"* ]]; then
        if command -v brew &> /dev/null; then
            brew install jq
        else
            log_color "$RED" "Error: jq required but not found. Install with: brew install jq"
            exit 1
        fi
    elif [[ "$OSTYPE" == "linux-gnu"* ]]; then
        log_color "$RED" "Error: jq required. Install with: sudo apt-get install jq or sudo yum install jq"
        exit 1
    fi
fi

log_color "$BOLD" "üîç RiskPrism Analyzing..."

# Detect input type and prepare request
IS_IAM=false
if jq -e '(.Version == "2012-10-17") or .Statement' "$PLAN_FILE" >/dev/null 2>&1; then
    IS_IAM=true
    echo "Detected IAM policy document..."
    FILE_CONTENT=$(cat "$PLAN_FILE")
    ENDPOINT="/analyze/iam"
    REQUEST_BODY=$(jq -n --argjson policy "$FILE_CONTENT" --argjson no_store "$STRICT_NO_STORE" \
        '{policy: $policy, options: {strict_no_store: $no_store}}')
    CHANGE_LABEL="Policy Statements"
    PRIMARY_ACTION_LABEL="Allow"
    SECONDARY_ACTION_LABEL="Deny"
elif jq empty "$PLAN_FILE" 2>/dev/null; then
    # Input is already valid JSON Terraform plan
    echo "Reading Terraform plan JSON..."
    FILE_CONTENT=$(cat "$PLAN_FILE")
    ENDPOINT="/analyze"
    REQUEST_BODY=$(jq -n --argjson plan "$FILE_CONTENT" --argjson no_store "$STRICT_NO_STORE" \
        '{plan_json: $plan, options: {strict_no_store: $no_store}}')
    CHANGE_LABEL="Resource Changes"
    PRIMARY_ACTION_LABEL="Creates"
    SECONDARY_ACTION_LABEL="Deletes"
else
    # Input is a binary plan file, convert to JSON
    echo "Converting Terraform binary plan to JSON..."
    FILE_CONTENT=$(terraform show -json "$PLAN_FILE" 2>&1)

    if [ $? -ne 0 ]; then
        log_color "$RED" "Error processing input file:"
        echo "$FILE_CONTENT"
        exit 1
    fi
    ENDPOINT="/analyze"
    REQUEST_BODY=$(jq -n --argjson plan "$FILE_CONTENT" --argjson no_store "$STRICT_NO_STORE" \
        '{plan_json: $plan, options: {strict_no_store: $no_store}}')
    CHANGE_LABEL="Resource Changes"
    PRIMARY_ACTION_LABEL="Creates"
    SECONDARY_ACTION_LABEL="Deletes"
fi

# Send to API
echo "Analyzing with security rules..."

# Build headers array
HEADERS=("-H" "Content-Type: application/json")
if [ ! -z "$INTERNAL_ACCESS_CODE" ]; then
    HEADERS+=("-H" "X-Internal-Code: $INTERNAL_ACCESS_CODE")
fi

# Use a temporary file for the response body
RESPONSE_FILE=$(mktemp)
HTTP_CODE=$(curl -s -o "$RESPONSE_FILE" -w "%{http_code}" -X POST "$API_URL$ENDPOINT" \
    "${HEADERS[@]}" \
    -d "$REQUEST_BODY")

# Check for successful response
if [ "$HTTP_CODE" -ne 200 ]; then
    log_color "$RED" "Error: API returned status $HTTP_CODE"
    if [ "$HTTP_CODE" -eq 401 ]; then
        log_color "$YELLOW" "Authentication failed. Please set your team access code:"
        echo "  export INTERNAL_ACCESS_CODE=your-secret-code"
    elif [ "$HTTP_CODE" -eq 000 ]; then
        log_color "$RED" "Failed to connect to API at $API_URL. Is the server running?"
    else
        log_color "$NC" "Detail: $(jq -r '.detail // "No details provided"' < "$RESPONSE_FILE")"
    fi
    rm -f "$RESPONSE_FILE"
    exit 1
fi

# Check if response is valid JSON
if ! jq empty "$RESPONSE_FILE" 2>/dev/null; then
    log_color "$RED" "Error: Invalid response from API"
    cat "$RESPONSE_FILE"
    rm -f "$RESPONSE_FILE"
    exit 1
fi

# Parse response from file directly to avoid shell mangling
RESPONSE_DATA() {
    jq -r "$1" < "$RESPONSE_FILE"
}

# Parse response
CACHED=$(RESPONSE_DATA '.cached')
TOTAL_CHANGES=$(RESPONSE_DATA '.summary.total_changes')
CREATES=$(RESPONSE_DATA '.summary.creates')
UPDATES=$(RESPONSE_DATA '.summary.updates')
DELETES=$(RESPONSE_DATA '.summary.deletes')
REPLACES=$(RESPONSE_DATA '.summary.replaces')

TOTAL_FINDINGS=$(RESPONSE_DATA '.risk_findings | length')
CRITICAL=$(RESPONSE_DATA '[.risk_findings[] | select(.severity=="critical")] | length')
HIGH=$(RESPONSE_DATA '[.risk_findings[] | select(.severity=="high")] | length')
MEDIUM=$(RESPONSE_DATA '[.risk_findings[] | select(.severity=="medium")] | length')
LOW=$(RESPONSE_DATA '[.risk_findings[] | select(.severity=="low")] | length')

# Display summary
CACHED_STR=""
if [ "$CACHED" = "true" ]; then
    CACHED_STR=" ${YELLOW}‚ö° (Cached Analysis)${NC}"
fi

printf "\n${BOLD}‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê${NC}\n"
printf "${BOLD}                  ANALYSIS SUMMARY$CACHED_STR${NC}\n"
printf "${BOLD}‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê${NC}\n\n"

# Resource changes
printf "${BOLD}$CHANGE_LABEL:${NC}\n"
printf "  Total: $TOTAL_CHANGES\n"
[ "$CREATES" != "0" ] && printf "  ${GREEN}$PRIMARY_ACTION_LABEL:${NC}  $CREATES\n"
[ "$UPDATES" != "0" ] && printf "  ${BLUE}Updates:${NC}  $UPDATES\n"
[ "$DELETES" != "0" ] && printf "  ${RED}$SECONDARY_ACTION_LABEL:${NC}  $DELETES\n"
[ "$REPLACES" != "0" ] || [ "$IS_IAM" = false ] && [ "$REPLACES" != "0" ] && printf "  ${YELLOW}Replaces:${NC} $REPLACES\n"
printf "\n"

# Security findings
printf "${BOLD}Security Findings: ${NC}$TOTAL_FINDINGS\n"
if [ "$TOTAL_FINDINGS" -gt 0 ]; then
    [ "$CRITICAL" != "0" ] && printf "  ${RED}${BOLD}üî¥ Critical:${NC} $CRITICAL\n"
    [ "$HIGH" != "0" ] && printf "  ${RED}üü† High:${NC}     $HIGH\n"
    [ "$MEDIUM" != "0" ] && printf "  ${YELLOW}üü° Medium:${NC}   $MEDIUM\n"
    [ "$LOW" != "0" ] && printf "  ${BLUE}üîµ Low:${NC}      $LOW\n"
else
    printf "  ${GREEN}‚úì No security issues found${NC}\n"
fi
printf "\n"

# Show critical and high findings details
if [ "$CRITICAL" != "0" ] || [ "$HIGH" != "0" ]; then
    printf "${BOLD}High Priority Findings:${NC}\n"
    printf "${BOLD}‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ${NC}\n"

    RESPONSE_DATA '.risk_findings[] | select(.severity=="critical" or .severity=="high") |
        "\n[\(.severity | ascii_upcase)] \(.title)\n  Resource: \(.resource_type)\n  ‚Üí \(.recommendation)"' | \
    while IFS= read -r line; do
        if [[ $line == \[CRITICAL\]* ]]; then
            log_color "$RED$BOLD" "$line"
        elif [[ $line == \[HIGH\]* ]]; then
            log_color "$RED" "$line"
        else
            printf "%s\n" "$line"
        fi
    done
    printf "\n"
fi

# Executive summary (if available)
EXEC_SUMMARY=$(RESPONSE_DATA '.explanation.executive_summary[]?' 2>/dev/null)
if [ ! -z "$EXEC_SUMMARY" ]; then
    printf "${BOLD}AI Summary:${NC}\n"
    printf "${BOLD}‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ${NC}\n"
    printf "%s\n" "$EXEC_SUMMARY" | while IFS= read -r line; do
        printf "  ‚Ä¢ %s\n" "$line"
    done
    printf "\n"
fi

# Footer with next steps
printf "${BOLD}‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê${NC}\n"

if [ "$CRITICAL" != "0" ]; then
    log_color "$RED$BOLD" "‚ö†Ô∏è  CRITICAL ISSUES FOUND - Review required"
    EXIT_CODE=2
elif [ "$HIGH" != "0" ]; then
    log_color "$YELLOW$BOLD" "‚ö†Ô∏è  HIGH RISK ISSUES - Review recommended"
    EXIT_CODE=1
else
    log_color "$GREEN$BOLD" "‚úì Analysis looks good"
    EXIT_CODE=0
fi

printf "\n"

# Extract session_id and show web UI link
SESSION_ID=$(RESPONSE_DATA '.session_id // empty')
if [ ! -z "$SESSION_ID" ]; then
    # Determine frontend URL based on API URL
    if [[ "$API_URL" == *"localhost"* ]] || [[ "$API_URL" == *"127.0.0.1"* ]]; then
        FRONTEND_URL="http://localhost:3000"
    else
        # Extract host from API URL and use port 3000
        FRONTEND_URL=$(echo "$API_URL" | sed 's/:8000/:3000/')
    fi
    printf "üìã Full report: %s/results/%s\n" "$FRONTEND_URL" "$SESSION_ID"
else
    printf "üìã No session saved (analysis complete)\n"
fi

printf "\n"

# Cleanup
rm -f "$RESPONSE_FILE"

exit $EXIT_CODE
