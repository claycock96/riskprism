#!/usr/bin/env bash
set -e

# Ensure we are running from the project root (optional for CLI but good for consistency)
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
# Note: riskprism doesn't strictly need root cd, but we'll include it for internal consistency
# if it ever needs to reference project assets.
# cd "$SCRIPT_DIR/.."

# riskprism - CLI tool for RiskPrism security analysis
# Usage: riskprism <plan-file> [api-url]

# Color codes
RED='\033[0;31m'
YELLOW='\033[1;33m'
GREEN='\033[0;32m'
BLUE='\033[0;34m'
BOLD='\033[1m'
NC='\033[0m' # No Color

# Helper for colored output that works across shells
log_color() {
    local color=$1
    shift
    printf "${color}%b${NC}\n" "$*"
}

# Default API URL
API_URL="${2:-http://localhost:8000}"

# Check if plan file provided
if [ -z "$1" ]; then
    echo "Usage: riskprism <plan-file> [api-url]"
    echo ""
    echo "Examples:"
    echo "  riskprism tfplan                    # Binary plan file"
    echo "  riskprism plan.json                 # JSON plan file"
    echo "  riskprism tfplan http://10.0.1.5:8000  # Use remote API"
    echo ""
    echo "Workflow (binary plan):"
    echo "  terraform plan -out=tfplan"
    echo "  riskprism tfplan"
    echo "  terraform apply tfplan"
    echo ""
    echo "Workflow (JSON plan):"
    echo "  terraform plan -out=tfplan"
    echo "  terraform show -json tfplan > plan.json"
    echo "  riskprism plan.json"
    exit 1
fi

PLAN_FILE=$1

# Check if plan file exists
if [ ! -f "$PLAN_FILE" ]; then
    log_color "$RED" "Error: Plan file '$PLAN_FILE' not found"
    exit 1
fi

# Check if terraform is installed
if ! command -v terraform &> /dev/null; then
    log_color "$RED" "Error: terraform command not found"
    echo "Please install Terraform: https://www.terraform.io/downloads"
    exit 1
fi

# Check if jq is installed
if ! command -v jq &> /dev/null; then
    log_color "$YELLOW" "Warning: jq not found. Installing for better output formatting..."
    # Try to install jq based on OS
    if [[ "$OSTYPE" == "darwin"* ]]; then
        if command -v brew &> /dev/null; then
            brew install jq
        else
            log_color "$RED" "Error: jq required but not found. Install with: brew install jq"
            exit 1
        fi
    elif [[ "$OSTYPE" == "linux-gnu"* ]]; then
        log_color "$RED" "Error: jq required. Install with: sudo apt-get install jq or sudo yum install jq"
        exit 1
    fi
fi

log_color "$BOLD" "ğŸ” RiskPrism Analyzing Plan...\n"

# Check if input is already JSON or a binary plan file
if jq empty "$PLAN_FILE" 2>/dev/null; then
    # Input is already valid JSON
    echo "Reading plan JSON file..."
    PLAN_JSON=$(cat "$PLAN_FILE")
else
    # Input is a binary plan file, convert to JSON
    echo "Converting plan to JSON..."
    PLAN_JSON=$(terraform show -json "$PLAN_FILE" 2>&1)

    if [ $? -ne 0 ]; then
        log_color "$RED" "Error converting plan to JSON:"
        echo "$PLAN_JSON"
        exit 1
    fi
fi

# Send to API
echo "Analyzing with security rules..."

# Build headers array
HEADERS=("-H" "Content-Type: application/json")
if [ ! -z "$INTERNAL_ACCESS_CODE" ]; then
    HEADERS+=("-H" "X-Internal-Code: $INTERNAL_ACCESS_CODE")
fi

# Wrap the plan JSON in the expected request format
REQUEST_BODY=$(jq -n --argjson plan "$PLAN_JSON" '{plan_json: $plan}')

# Use a temporary file for the response body
RESPONSE_FILE=$(mktemp)
HTTP_CODE=$(curl -s -o "$RESPONSE_FILE" -w "%{http_code}" -X POST "$API_URL/analyze" \
    "${HEADERS[@]}" \
    -d "$REQUEST_BODY")

# Check for successful response
if [ "$HTTP_CODE" -ne 200 ]; then
    log_color "$RED" "Error: API returned status $HTTP_CODE"
    if [ "$HTTP_CODE" -eq 401 ]; then
        log_color "$YELLOW" "Authentication failed. Please set your team access code:"
        echo "  export INTERNAL_ACCESS_CODE=your-secret-code"
    elif [ "$HTTP_CODE" -eq 000 ]; then
        log_color "$RED" "Failed to connect to API at $API_URL. Is the server running?"
    else
        log_color "$NC" "Detail: $(jq -r '.detail // "No details provided"' < "$RESPONSE_FILE")"
    fi
    rm -f "$RESPONSE_FILE"
    exit 1
fi

# Check if response is valid JSON
if ! jq empty "$RESPONSE_FILE" 2>/dev/null; then
    log_color "$RED" "Error: Invalid response from API"
    cat "$RESPONSE_FILE"
    rm -f "$RESPONSE_FILE"
    exit 1
fi

# Parse response from file directly to avoid shell mangling
RESPONSE_DATA() {
    jq -r "$1" < "$RESPONSE_FILE"
}

# Parse response
CACHED=$(RESPONSE_DATA '.cached')
TOTAL_CHANGES=$(RESPONSE_DATA '.summary.total_changes')
CREATES=$(RESPONSE_DATA '.summary.creates')
UPDATES=$(RESPONSE_DATA '.summary.updates')
DELETES=$(RESPONSE_DATA '.summary.deletes')
REPLACES=$(RESPONSE_DATA '.summary.replaces')

TOTAL_FINDINGS=$(RESPONSE_DATA '.risk_findings | length')
CRITICAL=$(RESPONSE_DATA '[.risk_findings[] | select(.severity=="critical")] | length')
HIGH=$(RESPONSE_DATA '[.risk_findings[] | select(.severity=="high")] | length')
MEDIUM=$(RESPONSE_DATA '[.risk_findings[] | select(.severity=="medium")] | length')
LOW=$(RESPONSE_DATA '[.risk_findings[] | select(.severity=="low")] | length')

# Display summary
CACHED_STR=""
if [ "$CACHED" = "true" ]; then
    CACHED_STR=" ${YELLOW}âš¡ (Cached Analysis)${NC}"
fi

printf "\n${BOLD}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}\n"
printf "${BOLD}                  ANALYSIS SUMMARY$CACHED_STR${NC}\n"
printf "${BOLD}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}\n\n"

# Resource changes
printf "${BOLD}Resource Changes:${NC}\n"
printf "  Total: $TOTAL_CHANGES\n"
[ "$CREATES" != "0" ] && printf "  ${GREEN}Creates:${NC}  $CREATES\n"
[ "$UPDATES" != "0" ] && printf "  ${BLUE}Updates:${NC}  $UPDATES\n"
[ "$DELETES" != "0" ] && printf "  ${RED}Deletes:${NC}  $DELETES\n"
[ "$REPLACES" != "0" ] && printf "  ${YELLOW}Replaces:${NC} $REPLACES\n"
printf "\n"

# Security findings
printf "${BOLD}Security Findings: ${NC}$TOTAL_FINDINGS\n"
if [ "$TOTAL_FINDINGS" -gt 0 ]; then
    [ "$CRITICAL" != "0" ] && printf "  ${RED}${BOLD}ğŸ”´ Critical:${NC} $CRITICAL\n"
    [ "$HIGH" != "0" ] && printf "  ${RED}ğŸŸ  High:${NC}     $HIGH\n"
    [ "$MEDIUM" != "0" ] && printf "  ${YELLOW}ğŸŸ¡ Medium:${NC}   $MEDIUM\n"
    [ "$LOW" != "0" ] && printf "  ${BLUE}ğŸ”µ Low:${NC}      $LOW\n"
else
    printf "  ${GREEN}âœ“ No security issues found${NC}\n"
fi
printf "\n"

# Show critical and high findings details
if [ "$CRITICAL" != "0" ] || [ "$HIGH" != "0" ]; then
    printf "${BOLD}High Priority Findings:${NC}\n"
    printf "${BOLD}â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€${NC}\n"

    RESPONSE_DATA '.risk_findings[] | select(.severity=="critical" or .severity=="high") |
        "\n[\(.severity | ascii_upcase)] \(.title)\n  Resource: \(.resource_type)\n  â†’ \(.recommendation)"' | \
    while IFS= read -r line; do
        if [[ $line == \[CRITICAL\]* ]]; then
            log_color "$RED$BOLD" "$line"
        elif [[ $line == \[HIGH\]* ]]; then
            log_color "$RED" "$line"
        else
            printf "%s\n" "$line"
        fi
    done
    printf "\n"
fi

# Executive summary (if available)
EXEC_SUMMARY=$(RESPONSE_DATA '.explanation.executive_summary[]?' 2>/dev/null)
if [ ! -z "$EXEC_SUMMARY" ]; then
    printf "${BOLD}AI Summary:${NC}\n"
    printf "${BOLD}â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€${NC}\n"
    printf "%s\n" "$EXEC_SUMMARY" | while IFS= read -r line; do
        printf "  â€¢ %s\n" "$line"
    done
    printf "\n"
fi

# Footer with next steps
printf "${BOLD}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}\n"

if [ "$CRITICAL" != "0" ]; then
    log_color "$RED$BOLD" "âš ï¸  CRITICAL ISSUES FOUND - Review required before apply"
    EXIT_CODE=2
elif [ "$HIGH" != "0" ]; then
    log_color "$YELLOW$BOLD" "âš ï¸  HIGH RISK ISSUES - Review recommended"
    EXIT_CODE=1
else
    log_color "$GREEN$BOLD" "âœ“ Plan looks good - proceed with terraform apply"
    EXIT_CODE=0
fi

printf "\n"

# Extract session_id and show web UI link
SESSION_ID=$(RESPONSE_DATA '.session_id // empty')
if [ ! -z "$SESSION_ID" ]; then
    # Determine frontend URL based on API URL
    if [[ "$API_URL" == *"localhost"* ]] || [[ "$API_URL" == *"127.0.0.1"* ]]; then
        FRONTEND_URL="http://localhost:3000"
    else
        # Extract host from API URL and use port 3000
        FRONTEND_URL=$(echo "$API_URL" | sed 's/:8000/:3000/')
    fi
    printf "ğŸ“‹ Full report: %s/results/%s\n" "$FRONTEND_URL" "$SESSION_ID"
else
    printf "ğŸ“‹ No session saved (analysis complete)\n"
fi

printf "\n"

# Cleanup
rm -f "$RESPONSE_FILE"

exit $EXIT_CODE
